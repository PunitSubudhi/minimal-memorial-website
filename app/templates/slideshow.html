<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Tribute Slideshow</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap"
      rel="stylesheet"
    >
    <style>
:root {
  color-scheme: dark;
  font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}

* {
  box-sizing: border-box;
}

body.slideshow-body {
  margin: 0;
  background: #050505;
  color: #f5f5f5;
  min-height: 100vh;
}

.slideshow-root {
  position: relative;
  min-height: 100vh;
  width: 100%;
  overflow: hidden;
  background: radial-gradient(circle at center, #161616 0%, #050505 65%, #000 100%);
}

.slide-container {
  position: absolute;
  inset: 0;
  overflow: hidden;
}

.slide {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity var(--slide-transition, 800ms) ease-in-out;
  pointer-events: none;
  padding: clamp(1.5rem, 4vh, 3rem) clamp(1.5rem, 4vw, 3rem);
}

.slide.is-visible {
  opacity: 1;
}

.slide__inner {
  display: flex;
  align-items: stretch;
  justify-content: space-between;
  gap: clamp(1.5rem, 4vw, 3.5rem);
  width: min(92vw, 1700px);
  height: min(86vh, 900px);
  padding: clamp(1.75rem, 3vh, 3rem);
  background: linear-gradient(135deg, rgba(10, 10, 10, 0.82) 0%, rgba(18, 18, 18, 0.68) 100%);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 1.75rem;
  box-shadow: 0 35px 120px rgba(0, 0, 0, 0.65);
  backdrop-filter: blur(12px);
  overflow: hidden;
}

.slide__media {
  flex: 1 1 58%;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  border-radius: 1.5rem;
  background: radial-gradient(circle at center, rgba(255, 255, 255, 0.08) 0%, rgba(0, 0, 0, 0.4) 55%, rgba(0, 0, 0, 0.85) 100%);
  overflow: hidden;
}

.slide__media::after {
  content: "";
  position: absolute;
  inset: 0;
  background: linear-gradient(180deg, rgba(0, 0, 0, 0.12), rgba(0, 0, 0, 0.35));
  pointer-events: none;
}

.slide__image {
  position: relative;
  z-index: 1;
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  transform: scale(1.01);
  transition: transform 10s ease-in-out;
}

.slide.is-visible .slide__image {
  transform: scale(1);
}

.slide__content {
  flex: 0 0 clamp(22rem, 30vw, 32rem);
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: space-between;
  padding: clamp(1.25rem, 2.5vh, 2.5rem);
  border-radius: 1.5rem;
  background: linear-gradient(180deg, rgba(5, 5, 5, 0.92) 0%, rgba(18, 18, 18, 0.75) 100%);
  border: 1px solid rgba(255, 255, 255, 0.06);
  gap: clamp(1rem, 2vh, 1.75rem);
  overflow: hidden;
  text-align: left;
}

.slide__header {
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  width: 100%;
}

.slide__name {
  margin: 0;
  font-size: clamp(1.55rem, 1.8vw, 2.25rem);
  font-weight: 600;
  letter-spacing: 0.04em;
  color: #ffffff;
}

.slide__timestamp {
  font-size: clamp(0.95rem, 1vw, 1.15rem);
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.7);
}

.slide__message {
  flex: 1 1 auto;
  margin: 0;
  width: 100%;
  font-size: clamp(1.2rem, 1.4vw, 1.9rem);
  line-height: 1.45;
  letter-spacing: 0.01em;
  color: rgba(245, 245, 245, 0.95);
  white-space: normal;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  line-clamp: 9;
  -webkit-line-clamp: 9;
  -webkit-box-orient: vertical;
  word-break: break-word;
}

.slide__message[data-truncated="true"]::after {
  content: "";
  display: block;
  width: 100%;
  height: 2rem;
  background: linear-gradient(180deg, rgba(18, 18, 18, 0) 0%, rgba(18, 18, 18, 1) 100%);
  margin-top: -2rem;
}

.slide__caption {
  margin: 0;
  font-size: clamp(0.95rem, 1vw, 1.2rem);
  color: rgba(255, 255, 255, 0.65);
  letter-spacing: 0.02em;
}

.slide__meta {
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  width: 100%;
  font-size: clamp(0.95rem, 0.95vw, 1.15rem);
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.5);
}

.slide--text-only .slide__inner {
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: min(82vw, 1100px);
  height: auto;
  padding: clamp(2rem, 4vh, 3.5rem);
  background: linear-gradient(160deg, rgba(10, 10, 10, 0.9) 0%, rgba(15, 15, 15, 0.7) 100%);
  gap: clamp(1.5rem, 3vh, 2.5rem);
}

.slide--text-only .slide__content {
  width: 100%;
  max-width: none;
  align-items: center;
  text-align: center;
  background: none;
  border: none;
  padding: 0;
  gap: clamp(0.75rem, 2vh, 1.5rem);
}

.slide--text-only .slide__message {
  line-clamp: 10;
  -webkit-line-clamp: 10;
  font-size: clamp(1.6rem, 2.3vw, 2.7rem);
}

.slide--text-only .slide__meta {
  align-items: center;
  text-transform: none;
  color: rgba(255, 255, 255, 0.65);
}

.slide--text-only .slide__caption {
  display: none;
}

.empty-state {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 1rem;
  background: #050505;
  color: rgba(255, 255, 255, 0.85);
  text-align: center;
  padding: 2.5rem;
}

.empty-state.hidden {
  display: none;
}

.empty-state__headline {
  margin: 0;
  font-size: clamp(1.6rem, 2vw + 1rem, 2.6rem);
}

.empty-state__cta {
  margin: 0;
  font-size: clamp(1rem, 1.2vw + 0.75rem, 1.4rem);
}

.empty-state__cta span {
  font-weight: 600;
  color: #ffffff;
}

.qr-overlay {
  position: absolute;
  right: clamp(1rem, 4vw, 3rem);
  bottom: clamp(1rem, 4vw, 3rem);
  background: rgba(0, 0, 0, 0.72);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 1.25rem;
  padding: 1.5rem;
  width: clamp(220px, 20vw, 280px);
  color: rgba(255, 255, 255, 0.85);
  font-size: 0.95rem;
  letter-spacing: 0.01em;
  backdrop-filter: blur(6px);
}

.qr-overlay__inner {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  align-items: center;
}

.qr-overlay__media {
  width: clamp(160px, 12vw, 200px);
  aspect-ratio: 1 / 1;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.04);
  border-radius: 0.75rem;
}

.qr-overlay__img {
  max-width: 100%;
  height: auto;
}

.qr-overlay__text {
  margin: 0;
  text-align: center;
  line-height: 1.3;
}

.qr-overlay__url {
  display: block;
  margin-top: 0.35rem;
  font-weight: 600;
  color: #fff;
}

@media (max-width: 1200px), (max-height: 760px) {
  .slide__inner {
    flex-direction: column;
    width: min(94vw, 1100px);
    height: auto;
  }

  .slide__media {
    width: 100%;
    min-height: clamp(220px, 42vh, 480px);
  }

  .slide__content {
    width: 100%;
    max-width: none;
  }

  .slide__message {
    line-clamp: 7;
    -webkit-line-clamp: 7;
  }

  .qr-overlay {
    position: static;
    margin: clamp(1.5rem, 4vh, 2.5rem) auto 0;
    width: min(260px, 80vw);
    background: rgba(0, 0, 0, 0.68);
  }
}

@media (max-width: 768px) {
  .slide {
    padding: clamp(1rem, 3vh, 1.75rem) clamp(1rem, 5vw, 1.5rem);
  }

  .slide__inner {
    padding: clamp(1.25rem, 3vh, 2rem);
    border-radius: 1.25rem;
  }

  .slide__content {
    padding: clamp(1rem, 3vh, 1.75rem);
  }

  .slide__message {
    font-size: clamp(1.1rem, 4vw, 1.45rem);
  }

  .slide__name {
    font-size: clamp(1.4rem, 4.5vw, 1.9rem);
  }
}
    </style>
  </head>
  <body class="slideshow-body">
    <main
      id="slideshow-root"
      class="slideshow-root"
      data-poll-interval="{{ poll_seconds }}"
      data-dwell="{{ dwell_ms }}"
      data-transition="{{ transition_ms }}"
      data-max-message-length="{{ max_message_length }}"
    >
      <div id="slide-container" class="slide-container" aria-live="polite" aria-atomic="true"></div>
      <div id="empty-state" class="empty-state" role="status">
        <p class="empty-state__headline">Tributes will appear here soon.</p>
        <p class="empty-state__cta">Share your memories at <span>{{ submission_url }}</span></p>
      </div>
      <aside class="qr-overlay" aria-label="Tribute submission link">
        <div class="qr-overlay__inner">
          <div class="qr-overlay__media" role="presentation">
            <img
              src="https://778bff83-75d6-44df-b16e-6f9c816261c4.s3.us-east-2.amazonaws.com/qrcode.svg"
              alt="QR code linking to the tribute form"
              class="qr-overlay__img"
              loading="lazy"
            >
          </div>
          <p class="qr-overlay__text">
            Share your memories at
            <span class="qr-overlay__url">{{ submission_url }}</span>
          </p>
        </div>
      </aside>
    </main>
    <script>
      window.SLIDESHOW_BOOTSTRAP = {
        pollSeconds: {{ poll_seconds }},
        dwellMilliseconds: {{ dwell_ms }},
        transitionMilliseconds: {{ transition_ms }},
        dataEndpoint: "{{ url_for('main.slideshow_data') }}",
        submissionUrl: "{{ submission_url }}",
        maxMessageLength: {{ max_message_length }}
      };
    </script>
    <script>
      (function () {
        const bootstrap = window.SLIDESHOW_BOOTSTRAP || {};
        const root = document.getElementById("slideshow-root");
        const container = document.getElementById("slide-container");
        const emptyState = document.getElementById("empty-state");

        if (!root || !container || !bootstrap.dataEndpoint) {
          console.warn("Slideshow bootstrap payload missing required elements.");
          return;
        }

        const params = new URLSearchParams(window.location.search);
        const debugMode = params.has("debug");

        const dwellMs = resolvePositive(
          debugMode ? params.get("duration") : bootstrap.dwellMilliseconds,
          bootstrap.dwellMilliseconds || 8000
        );
        const transitionMs = resolvePositive(
          bootstrap.transitionMilliseconds,
          bootstrap.transitionMilliseconds || 800
        );
        const pollSeconds = resolvePositive(
          bootstrap.pollSeconds,
          bootstrap.pollSeconds || 60
        );
        const messageLimit = resolveNonNegative(
          root.dataset.maxMessageLength ?? bootstrap.maxMessageLength
        );

        root.style.setProperty("--slide-transition", `${transitionMs}ms`);

        const shuffleOnce = debugMode && params.get("shuffle") === "true";

        let tributes = [];
        let currentTributeIndex = -1;
        let currentPhotoIndex = 0;
        let currentTributeId = null;
        let rotationTimer = null;
        let pollTimer = null;
        let etag = null;
        let lastModified = null;
        let backoffMultiplier = 1;

        fetchTributes();

        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "visible") {
            schedulePoll(500);
            if (getFrameCount() > 0) {
              scheduleRotation();
            }
          } else {
            clearTimeout(rotationTimer);
            clearTimeout(pollTimer);
          }
        });

        if (debugMode) {
          window.addEventListener("keydown", (event) => {
            if (event.key === "ArrowRight") {
              event.preventDefault();
              afterManualNavigation(() => advanceFrame(1));
            }
            if (event.key === "ArrowLeft") {
              event.preventDefault();
              afterManualNavigation(() => advanceFrame(-1));
            }
          });
        }

        function resolvePositive(rawValue, fallback) {
          const numeric = Number.parseInt(rawValue, 10);
          if (!Number.isFinite(numeric) || numeric <= 0) {
            return fallback;
          }
          return numeric;
        }

        function resolveNonNegative(rawValue) {
          const numeric = Number.parseInt(rawValue, 10);
          if (!Number.isFinite(numeric) || numeric < 0) {
            return 0;
          }
          return numeric;
        }

        function afterManualNavigation(callback) {
          clearTimeout(rotationTimer);
          callback();
        }

        function scheduleRotation() {
          clearTimeout(rotationTimer);
          if (getFrameCount() <= 1) {
            return;
          }
          rotationTimer = window.setTimeout(() => advanceFrame(1), dwellMs);
        }

        function schedulePoll(delayMs) {
          clearTimeout(pollTimer);
          pollTimer = window.setTimeout(() => {
            if (document.visibilityState === "hidden") {
              schedulePoll(delayMs);
              return;
            }
            fetchTributes();
          }, Math.max(delayMs, 1000));
        }

        async function fetchTributes() {
          const headers = new Headers();
          if (etag) {
            headers.set("If-None-Match", etag);
          }
          if (lastModified) {
            headers.set("If-Modified-Since", lastModified);
          }

          try {
            const response = await fetch(bootstrap.dataEndpoint, {
              method: "GET",
              headers,
              cache: "no-store"
            });

            if (response.status === 304) {
              backoffMultiplier = 1;
              schedulePoll(pollSeconds * 1000);
              return;
            }

            if (!response.ok) {
              throw new Error(`Request failed with status ${response.status}`);
            }

            etag = response.headers.get("ETag") || etag;
            lastModified = response.headers.get("Last-Modified") || lastModified;

            const payload = await response.json();
            const incoming = Array.isArray(payload.tributes) ? payload.tributes : [];
            const mergeResult = mergeTributes(incoming);

            if (!mergeResult.hasData) {
              clearCurrentSlide();
              schedulePoll(pollSeconds * 1000);
              return;
            }

            if (mergeResult.restartFromFirst) {
              advanceFrame(1);
            } else if (mergeResult.refreshCurrent) {
              const tribute = tributes[currentTributeIndex];
              if (tribute) {
                currentPhotoIndex = Math.min(
                  currentPhotoIndex,
                  Math.max(tribute.photos.length - 1, 0)
                );
                renderSlide(tribute, currentPhotoIndex);
                scheduleRotation();
              }
            } else if (currentTributeIndex === -1) {
              advanceFrame(1);
            }

            backoffMultiplier = 1;
            schedulePoll(pollSeconds * 1000);
          } catch (error) {
            console.error("Failed to fetch slideshow data", error);
            backoffMultiplier = Math.min(backoffMultiplier * 2, 6);
            schedulePoll(pollSeconds * 1000 * backoffMultiplier);
          }
        }

        function mergeTributes(incoming) {
          if (!incoming.length) {
            tributes = [];
            currentTributeIndex = -1;
            currentPhotoIndex = 0;
            currentTributeId = null;
            updateEmptyState();
            return { hasData: false, restartFromFirst: false, refreshCurrent: false };
          }

          const seen = new Set();
          const sanitized = [];

          for (const raw of incoming) {
            if (!raw || typeof raw !== "object") {
              continue;
            }
            const id = raw.id;
            if (id == null || seen.has(id)) {
              continue;
            }
            seen.add(id);
            sanitized.push(sanitizeTribute(raw));
          }

          sanitized.sort((a, b) => {
            const left = Date.parse(b.created_at || "");
            const right = Date.parse(a.created_at || "");
            return (Number.isFinite(left) ? left : 0) - (Number.isFinite(right) ? right : 0);
          });

          if (shuffleOnce) {
            shuffleArray(sanitized);
          }

          const previousId = currentTributeId;
          tributes = sanitized;
          updateEmptyState();

          if (!tributes.length) {
            currentTributeIndex = -1;
            currentPhotoIndex = 0;
            currentTributeId = null;
            return { hasData: false, restartFromFirst: false, refreshCurrent: false };
          }

          const locatedIndex = previousId != null
            ? tributes.findIndex((entry) => entry.id === previousId)
            : -1;

          if (locatedIndex !== -1) {
            currentTributeIndex = locatedIndex;
            currentTributeId = tributes[locatedIndex].id;
            currentPhotoIndex = Math.min(
              currentPhotoIndex,
              Math.max(tributes[locatedIndex].photos.length - 1, 0)
            );
            return { hasData: true, restartFromFirst: false, refreshCurrent: true };
          }

          currentTributeIndex = -1;
          currentPhotoIndex = 0;
          currentTributeId = null;
          return { hasData: true, restartFromFirst: true, refreshCurrent: false };
        }

        function sanitizeTribute(raw) {
          const message = typeof raw.message === "string" ? raw.message.trim() : "";
          const name = raw.name ? String(raw.name) : "Anonymous";
          const created = raw.created_at || new Date().toISOString();
          const photos = Array.isArray(raw.photos) ? raw.photos : [];
          const usablePhotos = photos
            .map((photo) => ({
              id: photo && photo.id != null ? photo.id : null,
              url: photo && typeof photo.url === "string" ? photo.url : null,
              caption: photo && typeof photo.caption === "string" ? photo.caption : "",
              content_type: photo && photo.content_type ? String(photo.content_type) : null
            }))
            .filter((photo) => Boolean(photo.url));

          return {
            id: raw.id,
            name,
            message,
            created_at: created,
            photos: usablePhotos,
            text_only: raw.text_only || usablePhotos.length === 0
          };
        }

        function advanceFrame(step) {
          if (!tributes.length) {
            return;
          }
          let movement = Number.isInteger(step) ? step : 1;
          if (movement === 0) {
            return;
          }

          while (movement !== 0) {
            if (movement > 0) {
              stepForward();
              movement -= 1;
            } else {
              stepBackward();
              movement += 1;
            }
          }

          const tribute = tributes[currentTributeIndex];
          if (tribute) {
            renderSlide(tribute, currentPhotoIndex);
            scheduleRotation();
          }
        }

        function stepForward() {
          if (currentTributeIndex === -1) {
            currentTributeIndex = 0;
            currentPhotoIndex = 0;
            currentTributeId = tributes[0].id;
            return;
          }

          const tribute = tributes[currentTributeIndex];
          const photoCount = tribute.photos.length;

          if (photoCount > 0 && currentPhotoIndex < photoCount - 1) {
            currentPhotoIndex += 1;
            return;
          }

          currentTributeIndex = (currentTributeIndex + 1) % tributes.length;
          currentPhotoIndex = 0;
          currentTributeId = tributes[currentTributeIndex].id;
        }

        function stepBackward() {
          if (currentTributeIndex === -1) {
            currentTributeIndex = tributes.length - 1;
            const tribute = tributes[currentTributeIndex];
            currentPhotoIndex = Math.max(tribute.photos.length - 1, 0);
            currentTributeId = tribute.id;
            return;
          }

          const tribute = tributes[currentTributeIndex];
          if (tribute.photos.length > 0 && currentPhotoIndex > 0) {
            currentPhotoIndex -= 1;
            return;
          }

          currentTributeIndex = (currentTributeIndex - 1 + tributes.length) % tributes.length;
          const previous = tributes[currentTributeIndex];
          currentPhotoIndex = Math.max(previous.photos.length - 1, 0);
          currentTributeId = previous.id;
        }

        function renderSlide(tribute, photoIndex) {
          if (!tribute) {
            return;
          }

          currentTributeId = tribute.id;

          const nextSlide = buildSlideElement(tribute, photoIndex);
          nextSlide.style.setProperty("--slide-transition", `${transitionMs}ms`);

          container.replaceChildren(nextSlide);
          window.requestAnimationFrame(() => {
            nextSlide.classList.add("is-visible");
          });

          updateEmptyState();
          preloadUpcoming();
        }

        function buildSlideElement(tribute, photoIndex) {
          const article = document.createElement("article");
          article.className = "slide";

          const photo = selectPhoto(tribute, photoIndex);
          if (!photo) {
            article.classList.add("slide--text-only");
          }

          const frame = document.createElement("div");
          frame.className = "slide__inner";
          article.appendChild(frame);

          if (photo) {
            const media = document.createElement("figure");
            media.className = "slide__media";

            const img = document.createElement("img");
            img.className = "slide__image";
            img.src = photo.url;
            img.alt = photo.caption || `Tribute photo for ${tribute.name}`;
            const initialLoad = container.childElementCount === 0;
            img.loading = initialLoad ? "eager" : "lazy";
            img.decoding = "async";
            media.appendChild(img);

            frame.appendChild(media);
          }

          const content = document.createElement("div");
          content.className = "slide__content";
          frame.appendChild(content);

          const header = document.createElement("header");
          header.className = "slide__header";

          const nameEl = document.createElement("h2");
          nameEl.className = "slide__name";
          nameEl.textContent = tribute.name;
          header.appendChild(nameEl);

          const timestampEl = document.createElement("time");
          timestampEl.className = "slide__timestamp";
          const timestampText = formatTimestamp(tribute.created_at);
          if (timestampText) {
            timestampEl.textContent = timestampText;
            try {
              timestampEl.dateTime = new Date(tribute.created_at).toISOString();
            } catch (_err) {
              timestampEl.dateTime = "";
            }
          }
          header.appendChild(timestampEl);
          content.appendChild(header);

          const messageInfo = truncateMessage(tribute.message, messageLimit);
          const messageEl = document.createElement("p");
          messageEl.className = "slide__message";
          messageEl.textContent = messageInfo.text;
          messageEl.dataset.truncated = String(messageInfo.truncated);
          messageEl.dataset.fullMessage = messageInfo.full;
          if (messageInfo.full) {
            messageEl.title = messageInfo.full;
          }
          content.appendChild(messageEl);

          if (photo && photo.caption) {
            const captionEl = document.createElement("p");
            captionEl.className = "slide__caption";
            captionEl.textContent = photo.caption;
            content.appendChild(captionEl);
          }

          if (photo && tribute.photos.length > 1) {
            const meta = document.createElement("div");
            meta.className = "slide__meta";
            const status = document.createElement("span");
            status.textContent = `Photo ${photoIndex + 1} of ${tribute.photos.length}`;
            meta.appendChild(status);
            content.appendChild(meta);
          }

          return article;
        }

        function selectPhoto(tribute, photoIndex) {
          if (!tribute || !Array.isArray(tribute.photos) || tribute.photos.length === 0) {
            return null;
          }
          const clampedIndex = Math.max(0, Math.min(photoIndex || 0, tribute.photos.length - 1));
          return tribute.photos[clampedIndex];
        }

        function formatTimestamp(value) {
          try {
            const date = new Date(value);
            if (Number.isNaN(date.getTime())) {
              throw new Error("Invalid date");
            }
            return new Intl.DateTimeFormat(undefined, {
              dateStyle: "long",
              timeStyle: "short"
            }).format(date);
          } catch (_err) {
            return "";
          }
        }

        function truncateMessage(message, limit) {
          const safeMessage = typeof message === "string" ? message.trim() : "";
          if (!limit || limit <= 0 || safeMessage.length <= limit) {
            return { text: safeMessage, full: safeMessage, truncated: false };
          }

          let truncated = safeMessage.slice(0, limit);
          const lastSpace = truncated.lastIndexOf(" ");
          if (lastSpace > Math.floor(limit * 0.6)) {
            truncated = truncated.slice(0, lastSpace);
          }
          truncated = truncated.replace(/[\s,;:-]+$/u, "");

          return {
            text: `${truncated}...`,
            full: safeMessage,
            truncated: true
          };
        }

        function preloadUpcoming() {
          const peek = advanceIndices(currentTributeIndex, currentPhotoIndex, 1);
          if (peek.tributeIndex === -1) {
            return;
          }
          const upcomingTribute = tributes[peek.tributeIndex];
          const upcomingPhoto = selectPhoto(upcomingTribute, peek.photoIndex);
          if (upcomingPhoto && upcomingPhoto.url) {
            const img = new Image();
            img.src = upcomingPhoto.url;
          }
        }

        function advanceIndices(tributeIndex, photoIndex, direction) {
          if (!tributes.length) {
            return { tributeIndex: -1, photoIndex: 0 };
          }

          let idx = tributeIndex;
          let pIdx = photoIndex;
          let remaining = direction >= 0 ? direction : -direction;
          const step = direction >= 0 ? 1 : -1;

          while (remaining > 0) {
            if (step > 0) {
              if (idx === -1) {
                idx = 0;
                pIdx = 0;
              } else {
                const tribute = tributes[idx];
                const photoCount = tribute.photos.length;
                if (photoCount > 0 && pIdx < photoCount - 1) {
                  pIdx += 1;
                } else {
                  idx = (idx + 1) % tributes.length;
                  pIdx = 0;
                }
              }
            } else {
              if (idx === -1) {
                idx = tributes.length - 1;
                const tribute = tributes[idx];
                pIdx = Math.max(tribute.photos.length - 1, 0);
              } else {
                const tribute = tributes[idx];
                if (tribute.photos.length > 0 && pIdx > 0) {
                  pIdx -= 1;
                } else {
                  idx = (idx - 1 + tributes.length) % tributes.length;
                  const prev = tributes[idx];
                  pIdx = Math.max(prev.photos.length - 1, 0);
                }
              }
            }
            remaining -= 1;
          }

          return { tributeIndex: idx, photoIndex: pIdx };
        }

        function getFrameCount() {
          return tributes.reduce((total, tribute) => {
            const photoCount = Array.isArray(tribute.photos) && tribute.photos.length
              ? tribute.photos.length
              : 1;
            return total + photoCount;
          }, 0);
        }

        function shuffleArray(list) {
          for (let i = list.length - 1; i > 0; i -= 1) {
            const j = Math.floor(Math.random() * (i + 1));
            const temp = list[i];
            list[i] = list[j];
            list[j] = temp;
          }
        }

        function clearCurrentSlide() {
          container.innerHTML = "";
          currentTributeId = null;
          currentTributeIndex = -1;
          currentPhotoIndex = 0;
          updateEmptyState();
        }

        function updateEmptyState() {
          if (!emptyState) {
            return;
          }
          if (getFrameCount() === 0) {
            emptyState.classList.remove("hidden");
          } else {
            emptyState.classList.add("hidden");
          }
        }
      })();
    </script>
  </body>
</html>
